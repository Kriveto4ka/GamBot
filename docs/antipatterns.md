# Антипаттерны

## Смешивание naive и aware дат при вычислении оставшегося времени

### Симптомы
- Ошибка `TypeError: can't subtract offset-naive and offset-aware datetimes` при открытии списка задач

### Почему это плохо
- Инлайн-кнопки перестают работать при наличии задач
- Ошибка возникает в рантайме, а не при старте

### Как правильно
- Всегда приводить даты к одному типу (aware) перед вычислениями
- Если в базе сохраняются naive даты, явно назначать часовой пояс при чтении

### Что нельзя делать
- Вычитать даты с разными типами timezone

---

## Сохранение дедлайнов без UTC-нормализации

### Симптомы
- Дедлайны создаются на 3 часа раньше или позже ожидаемого
- Проверка просрочки работает по UTC, а ввод в локальном времени

### Почему это плохо
- Пользователь теряет доверие из‑за некорректных дедлайнов
- Уведомления и урон срабатывают не вовремя

### Как правильно
- Всегда переводить пользовательский ввод в UTC перед сохранением
- Хранить даты в UTC и конвертировать в локальный TZ только при отображении

### Что нельзя делать
- Хранить локальные даты без TZ-информации

---

## Некорректная сигнатура обработчика ошибок aiogram

### Симптомы
- Ошибка `TypeError: on_error() missing 1 required positional argument: 'exception'`

### Почему это плохо
- Ошибки в обработчиках теряются или вызывают дополнительные падения

### Как правильно
- Использовать сигнатуру, совместимую с aiogram: принимать **kwargs и извлекать exception

### Что нельзя делать
- Ожидать, что aiogram всегда передаст exception как позиционный аргумент

---

## Кнопка есть, обработчика нет

### Симптомы
- Сообщение `Update ... is not handled`
- Нажатие на инлайн-кнопку не приводит к действию

### Почему это плохо
- Пользовательский поток прерывается без объяснения
- Невозможно завершить задачу или вернуться в меню

### Как правильно
- Для каждой callback_data должна быть обработка
- Добавлять fallback-логирование для неизвестных callback_data

### Что нельзя делать
- Добавлять кнопку без соответствующего обработчика

---

## Несовместимость callback-фильтров с версией aiogram

### Симптомы
- При нажатии на кнопки нет обработки, хотя фильтр кажется корректным
- В логах появляются `Unhandled callback data=...`

### Почему это плохо
- Пользователь не может завершить сценарии
- Ошибка маскируется отсутствием исключений

### Как правильно
- Использовать фильтры, доступные в конкретной версии aiogram
- Проверять обработку callback_data на каждом экране

### Что нельзя делать
- Подключать фильтры, которых нет в установленной версии aiogram

---

## Состояние FSM не совпадает с ожидаемым при обработке кнопок

### Симптомы
- При выборе сложности или дедлайна появляется сообщение «Кнопка недоступна»

### Почему это плохо
- Пользовательский поток создания задачи прерывается

### Как правильно
- Обрабатывать callback независимо от состояния и валидировать state внутри обработчика
- Для несоответствий выдавать понятную подсказку, что делать дальше

### Что нельзя делать
- Полагаться на фильтр состояния без fallback‑логики

---

## Отсутствует драйвер psycopg для SQLAlchemy

### Симптомы
```
ModuleNotFoundError: No module named 'psycopg'
```

### Почему это плохо
- Приложение падает на старте и не может подключиться к PostgreSQL
- Контейнер бота завершается с ошибкой

### Как правильно
- Установить драйвер PostgreSQL для SQLAlchemy
- Использовать `psycopg` (рекомендуется) или `psycopg2-binary` в зависимостях

### Что нельзя делать
- Запускать бота без установленного драйвера PostgreSQL

---

## psycopg установлен без бинарной или libpq‑зависимости

### Симптомы
```
ImportError: no pq wrapper available.
Attempts made:
- couldn't import psycopg 'c' implementation: No module named 'psycopg_c'
- couldn't import psycopg 'binary' implementation: No module named 'psycopg_binary'
- couldn't import psycopg 'python' implementation: libpq library not found
```

### Почему это плохо
- Бот не стартует, потому что драйвер не может загрузить libpq или бинарную реализацию
- Ошибка проявляется только на старте контейнера

### Как правильно
- Установить `psycopg[binary]` в зависимостях, чтобы использовать встроенные бинарные колёса
- Либо установить системную библиотеку libpq и сборочные зависимости

### Что нельзя делать
- Использовать `psycopg` без `binary` или без установленного libpq в контейнере

---

## Неверные креды PostgreSQL в DATABASE_URL

### Симптомы
```
psycopg.OperationalError: connection failed: ... FATAL:  password authentication failed for user "bot"
```

### Почему это плохо
- Бот не запускается, потому что не может подключиться к базе
- Ошибка возникает до старте логики и сообщений

### Как правильно
- Привести `DATABASE_URL` и переменные `POSTGRES_USER/POSTGRES_PASSWORD/POSTGRES_DB` к одной паре логина/пароля
- Убедиться, что значения совпадают в `.env` и `docker-compose.yml`

### Что нельзя делать
- Использовать пользователя/пароль, не совпадающие с настройками контейнера PostgreSQL

---

## Использование telegram_id вместо внутреннего user_id в запросах

### Симптомы
```
psycopg.errors.NumericValueOutOfRange: integer out of range
... WHERE tasks.id = ... AND tasks.user_id = ...
```

### Почему это плохо
- Запросы к задачам падают, потому что `tasks.user_id` хранит внутренний идентификатор пользователя, а не `telegram_id`
- Ошибка проявляется при открытии задачи и ломает пользовательский поток

### Как правильно
- Всегда получать пользователя из БД и использовать `user.id` во всех запросах к задачам
- `telegram_id` использовать только для поиска пользователя

### Что нельзя делать
- Прокидывать `telegram_id` в `tasks.user_id`

---

## [AP-002] Использование ORM-объекта после закрытия сессии

### Симптомы
- Возможные ошибки LazyLoaded/DetachedInstance при обращении к атрибутам модели
- Работает только при использовании уже загруженных атрибутов

### Почему это плохо
- Не предсказуемое поведение при изменении настроек сессии
- Риск ошибок при добавлении новых полей или связей

### Как правильно
- Не добавлять к модели `User` ленивые `relationship`, используемые в обработчиках
- При необходимости передавать из сессии только нужные скалярные поля (например, через DTO или словарь), собранные внутри контекста сессии

### Что нельзя делать
- Использовать ORM-объекты после закрытия сессии

---

## [AP-003] Вызов edit_text без проверки изменения контента

### Симптомы
- Ошибка `TelegramBadRequest: Message is not modified` при нажатии на кнопку
- Логирование ошибок при повторном нажатии на ту же кнопку

### Почему это плохо
- Портит пользовательский опыт из-за всплывающих ошибок
- Увеличивает количество ненужных логов

### Как правильно
- Использовать функцию `safe_edit_text` из `bot/safe_edit.py`
- Функция перехватывает ошибку «Message is not modified» и игнорирует её

### Что нельзя делать
- Вызывать `edit_text` напрямую без обработки ошибок

---

## [AP-004] Обращение к результату scalar_one_or_none() как к Row (row[0])

### Симптомы
- Ошибка `TypeError: 'datetime' object is not subscriptable` при наличии активных задач
- Падение при открытии главного меню или экрана персонажа

### Почему это плохо
- Блокирует пользовательский поток
- Ошибка возникает в рантайме при обычном взаимодействии

### Как правильно
- Для запросов с одной колонкой использовать результат `scalar_one_or_none()` напрямую
- Не пытаться получить `row[0]` из скалярного значения

### Что нельзя делать
- Обрабатывать результат `scalar_one_or_none()` как объект Row

---

## [AP-005] Дублирование функции _safe_edit в нескольких модулях

### Симптомы
- Одна и та же логика реализована в `bot/handlers/menu.py`, `bot/handlers/task_create.py` и `bot/handlers/task_list.py`
- Разные названия функций: `_safe_edit_text`, `_safe_edit`

### Почему это плохо
- Усложняет поддержку — изменения нужно вносить в несколько мест
- Риск расхождений в поведении при обновлении

### Как правильно
- Использовать общую функцию `safe_edit_text` из модуля `bot/safe_edit.py`
- Импортировать функцию в всех обработчиках, где нужна безопасная правка сообщений

### Что нельзя делать
- Дублировать код ошибки обработки `edit_text` в разных модулях

---

## [AP-006] HTTP-запросы внутри транзакции БД

### Симптомы
- Долгие транзакции из-за сетевых запросов
- Риск блокировок БД при медленном ответа Telegram API

### Почему это плохо
- Снижает пропускную способность системы
- Увеличивает вероятность ошибок при высокой нагрузке

### Как правильно
- Разделить логику на два этапа:
  1. В транзакции собирать данные и обновлять состояние
  2. После `commit()` отправлять уведомления через Telegram API

### Что нельзя делать
- Выполнять HTTP-запросы внутри контекста `async with async_session()`

---

## [AP-007] Устаревшие комментарии в коде

### Симптомы
- Комментарии не соответствуют текущей реализации
- Например, комментарий `Phase 2: no XP` при уже работающей системе начисления XP

### Почему это плохо
- Вводит в заблуждение при чтении кода
- Усложняет поддержку и понимание логики

### Как правильно
- Актуализировать комментарии при каждом изменении логики
- Удалять комментарии, которые больше не отражают реальность

### Что нельзя делать
- Оставлять устаревшие комментарии в коде

---

## [AP-008] Использование Emoji в консольном выводе тестов без явной кодировки

### Симптомы
- Ошибка `UnicodeEncodeError` при запуске тестов на Windows
- Невозможно запустить тесты "из коробки" без дополнительной конфигурации

### Почему это плохо
- Затрудняет разработку на Windows
- Уменьшает доступность проекта для разработчиков на разных платформах

### Как правильно
- Добавить в тесты явную конфигурацию кодировки: `sys.stdout.reconfigure(encoding='utf-8')`
- Либо избегать использования сложных Unicode-символов в консольном выводе

### Что нельзя делать
- Использовать Emoji в тестах без явной настройки кодировки

---

## [AP-009] Неполный regex для парсинга дней в deadline_parser

### Симптомы
- Парсер не распознаёт ввод «через 1 день», но работает с «через 2 дня» или «через 5 дней»
- Возвращает `None` для некоторых вариантов относительных дат

### Почему это плохо
- Неполная поддержка ввода пользователя
- Пользователь не понимает, почему ввод «через 1 день» не работает

### Как правильно
- Использовать regex `r'через\s+(\d+)\s+(дн|день)'` для поддержки всех вариантов написания
- Тестировать парсер с разными входными данными

### Что нельзя делать
- Использовать неполные regex для парсинга пользовательского ввода

---

## [AP-010] Смешивание timezone-aware и naive datetime

### Симптомы
- Ошибка `TypeError: can't subtract offset-naive and offset-aware datetimes` при создании задачи
- Невозможность сохранения дедлайна в БД

### Почему это плохо
- Блокирует создание задач
- Ошибка возникает при критической операции для пользователя

### Как правильно
- Удалять tzinfo из даты перед сохранением в БД: `deadline.replace(tzinfo=None)`
- Хранить все дедлайны в UTC как naive datetime

### Что нельзя делать
- Сохранять timezone-aware datetime в БД с полем `TIMESTAMP WITHOUT TIME ZONE`

---

## [AP-011] Использование selectinload для несуществующего relationship

### Симптомы
- Ошибка `AttributeError: type object 'Task' has no attribute 'user'` при проверке дедлайнов
- Падение планировщика при запуске

### Почему это плохо
- Бот не может проверять дедлайны
- Ошибка возникает при старте бота

### Как правильно
- Добавить relationship в модель Task: `user = relationship("User", backref="tasks")`
- Импортировать `relationship` из `sqlalchemy.orm`

### Что нельзя делать
- Использовать `selectinload` для несуществующих полей модели

---

## [AP-012] Сравнение naive и aware datetime в функциях форматирования

### Симптомы
- Ошибка `TypeError: can't compare offset-naive and offset-aware datetimes` при открытии списка задач
- Невозможность отобразить оставшееся время до дедлайна

### Почему это плохо
- Блокирует пользовательский поток
- Ошибка возникает при обычном взаимодействии

### Как правильно
- Использовать `datetime.utcnow()` вместо `get_now_utc()` для сравнения с naive datetime из БД
- В `format_deadline_date` добавить приведение naive datetime к aware перед `astimezone()`

### Что нельзя делать
- Сравнивать timezone-aware и naive datetime напрямую
